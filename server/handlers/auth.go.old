package handlers

import (
	"fmt"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/session"

	"github.com/golang-jwt/jwt/v5"

	"github.com/spf13/viper"
	"terra9.it/checkmate/server/models"
	"terra9.it/checkmate/server/repository"
)

// Login route
func Login(c *fiber.Ctx) error {
	// Extract the credentials from the request body
	loginRequest := new(models.LoginRequest)
	if err := c.BodyParser(loginRequest); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}
	// Find the user by credentials
	user, err := repository.FindByCredentials(loginRequest.Email, loginRequest.Password)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": err.Error(),
		})
	}
	day := time.Hour * 24
	// Create the JWT claims, which includes the user ID and expiry time
	claims := jwt.MapClaims{
		"ID":         user.ID,
		"email":      user.Email,
		"session_id": user.SessionID,
		"exp":        time.Now().Add(day * 1).Unix(),
	}
	// Create token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	// Generate encoded token and send it as response.
	key := viper.GetString("AUTH_SECRET")

	t, err := token.SignedString([]byte(key))
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}
	// Return the token
	return c.JSON(models.LoginResponse{
		Token: t,
		User: models.UserResponse{
			Email: user.Email,
		},
	})
}

func AuthUser(c *fiber.Ctx) error {
	claims, err := ClaimsFromContext(c)
	if err != nil {
		return err
	}
	return c.JSON(fiber.Map{
		"ID":    claims["ID"],
		"email": claims["email"],
	})
}

func Logout(c *fiber.Ctx) error {
	s := c.Locals("session")
	if s != nil {
		if sess := s.(*session.Session); sess != nil {
			sess.Destroy()
		}
	}
	c.Locals("user", nil)
	return c.Next() //c.Redirect("/", fiber.StatusTemporaryRedirect)
}

// Token route
func Token(c *fiber.Ctx) error {

	claims, err := ClaimsFromContext(c)
	if err != nil {
		return err
	}
	//day := time.Hour * 24
	// Create the JWT claims, which includes the user ID and expiry time
	newclaims := jwt.MapClaims{
		"ID":         claims["ID"],
		"email":      claims["email"],
		"session_id": claims["session_id"],
		//"exp":        time.Now().Add(day * 1).Unix(),
		"exp": time.Now().Add(time.Second * 1).Unix(),
	}
	// Create token
	newtoken := jwt.NewWithClaims(jwt.SigningMethodHS256, newclaims)
	// Generate encoded token and send it as response.
	key := viper.GetString("AUTH_SECRET")
	t, err := newtoken.SignedString([]byte(key))
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}
	// Return the token
	return c.JSON(models.LoginResponse{
		Token: t,
	})
}

func ClaimsFromContext(c *fiber.Ctx) (jwt.MapClaims, error) {
	u := c.Locals("user")
	if u == nil {
		return nil, fmt.Errorf("unauthorized")
	}
	// Check if the token is valid
	token := u.(*jwt.Token)
	if token == nil || !token.Valid {
		return nil, fmt.Errorf("invalid token")
	}
	// Extract the claims from the token
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return nil, fmt.Errorf("invalid token claims")
	}
	return claims, nil
}
